"""Utilities for converting images to G-code."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, List, Sequence

import numpy as np
from PIL import Image


class GCodeError(RuntimeError):
    """Raised when G-code generation fails."""


@dataclass
class GCodeSettings:
    """Settings controlling image-to-G-code conversion."""

    pixel_size_mm: float = 0.25
    feed_rate: int = 1200
    travel_height: float = 5.0
    draw_height: float = 0.0
    darkness_threshold: int = 128


def image_to_gcode(image_path: Path, output_path: Path, settings: GCodeSettings | None = None) -> Path:
    """Convert a raster image to G-code file."""
    if settings is None:
        settings = GCodeSettings()

    if not image_path.exists():
        raise GCodeError(f"Image '{image_path}' does not exist.")

    image = Image.open(image_path).convert("L")
    data = np.array(image)
    binary = data < settings.darkness_threshold

    commands: List[str] = [
        "; Generated by AI Plotter",
        "G21 ; set units to mm",
        "G90 ; absolute positioning",
        f"G1 Z{settings.travel_height:.2f} F{settings.feed_rate}",
    ]

    height, width = binary.shape
    pixel = settings.pixel_size_mm

    for row in range(height):
        y = (height - row - 1) * pixel
        segments = _row_segments(binary[row])
        if not segments:
            continue
        serpentine = row % 2 == 1
        segment_iter = reversed(segments) if serpentine else segments

        for start, end in segment_iter:
            if serpentine:
                x_start = end * pixel
                x_end = start * pixel
            else:
                x_start = start * pixel
                x_end = end * pixel
            commands.append(f"G0 X{x_start:.2f} Y{y:.2f}")
            commands.append(f"G1 Z{settings.draw_height:.2f} F{settings.feed_rate}")
            commands.append(f"G1 X{x_end:.2f} Y{y:.2f} F{settings.feed_rate}")
            commands.append(f"G1 Z{settings.travel_height:.2f} F{settings.feed_rate}")

    commands.extend(
        [
            "G0 X0 Y0",
            f"G1 Z{settings.travel_height:.2f}",
            "M5 ; pen up",
        ]
    )

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(commands), encoding="utf-8")
    return output_path


def _row_segments(row: Sequence[bool]) -> List[tuple[int, int]]:
    """Return contiguous drawing segments for a binary row."""
    segments: List[tuple[int, int]] = []
    start = None
    for idx, on in enumerate(row):
        if on:
            if start is None:
                start = idx
        elif start is not None:
            segments.append((start, idx))
            start = None
    if start is not None:
        segments.append((start, len(row)))
    return segments

