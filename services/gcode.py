"""Utilities for converting images to G-code."""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import List, Sequence

import cv2
import numpy as np
from PIL import Image


class GCodeError(RuntimeError):
    """Raised when G-code generation fails."""


@dataclass
class GCodeSettings:
    """Settings controlling image-to-G-code conversion."""

    pixel_size_mm: float = 0.25
    feed_rate: int = 1200
    travel_height: float = 5.0
    draw_height: float = 0.0
    invert_z: bool = False
    canny_threshold1: int = 60
    canny_threshold2: int = 180
    blur_kernel_size: int = 5
    dilate_iterations: int = 1
    contour_tolerance: float = 0.01
    min_contour_length: int = 40
    point_skip: int = 1


def image_to_gcode(image_path: Path, output_path: Path, settings: GCodeSettings | None = None) -> Path:
    """Convert a raster image to G-code file."""
    if settings is None:
        settings = GCodeSettings()

    if not image_path.exists():
        raise GCodeError(f"Image '{image_path}' does not exist.")

    image = Image.open(image_path).convert("L")
    gray = np.array(image)

    if settings.blur_kernel_size and settings.blur_kernel_size % 2 == 1:
        gray = cv2.GaussianBlur(gray, (settings.blur_kernel_size, settings.blur_kernel_size), 0)

    edges = cv2.Canny(gray, settings.canny_threshold1, settings.canny_threshold2)

    if settings.dilate_iterations > 0:
        kernel = np.ones((3, 3), np.uint8)
        edges = cv2.dilate(edges, kernel, iterations=settings.dilate_iterations)

    pen_up = settings.travel_height
    pen_down = settings.draw_height
    if settings.invert_z:
        pen_up, pen_down = pen_down, pen_up

    commands: List[str] = [
        "; Generated by AI Plotter",
        "G21 ; set units to mm",
        "G90 ; absolute positioning",
        f"G1 Z{pen_up:.2f} F{settings.feed_rate}",
    ]

    height, width = gray.shape
    pixel = settings.pixel_size_mm

    contours, _ = cv2.findContours(edges, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)

    if not contours:
        raise GCodeError("No contours detected; cannot generate outline.")

    contours = sorted(contours, key=cv2.contourArea, reverse=True)

    drawn_any = False

    for contour in contours:
        if len(contour) < settings.min_contour_length:
            continue

        epsilon = settings.contour_tolerance * cv2.arcLength(contour, closed=True)
        if epsilon > 0:
            contour = cv2.approxPolyDP(contour, epsilon, closed=True)

        points = contour.squeeze()
        if points.ndim != 2 or len(points) < 2:
            continue

        if settings.point_skip > 1:
            points = points[:: settings.point_skip]
            if len(points) < 2:
                continue

        path_points = _contour_to_path(points, height, pixel)

        x0, y0 = path_points[0]
        commands.append(f"G0 X{x0:.2f} Y{y0:.2f}")
        commands.append(f"G1 Z{pen_down:.2f} F{settings.feed_rate}")

        for x, y in path_points[1:]:
            commands.append(f"G1 X{x:.2f} Y{y:.2f} F{settings.feed_rate}")

        commands.append(f"G1 Z{pen_up:.2f} F{settings.feed_rate}")
        drawn_any = True

    if not drawn_any:
        raise GCodeError("Contours were detected but did not meet length requirements.")

    commands.extend(
        [
            "G0 X0 Y0",
            f"G1 Z{pen_up:.2f}",
            "M5 ; pen up",
        ]
    )

    output_path.parent.mkdir(parents=True, exist_ok=True)
    output_path.write_text("\n".join(commands), encoding="utf-8")
    return output_path


def _contour_to_path(points: Sequence[Sequence[int]], height: int, pixel: float) -> List[tuple[float, float]]:
    """Convert contour pixel points to plotter coordinates."""
    path: List[tuple[float, float]] = []
    for px, py in points:
        x_mm = float(px) * pixel
        y_mm = (height - float(py)) * pixel
        path.append((x_mm, y_mm))

    # Ensure closed loop ends back at start for smooth outline
    if path and (path[0][0] != path[-1][0] or path[0][1] != path[-1][1]):
        path.append(path[0])
    return path

